/**
 * Vercel Serverless Function (Secure Proxy)
 * This file securely reads the GEMINI_API_KEY from the Vercel environment 
 * variables and uses it to call the Google Gemini API, hiding the key from the public frontend.
 */
const GEMINI_API_KEY = process.env.GEMINI_API_KEY; 
const MODEL = "gemini-2.5-flash-preview-09-2025";
const MAX_RETRIES = 5;

// Define the system instruction for the model
const systemInstruction = {
    parts: [{ text: "You are TaxGPT. Provide clear, structured tax analysis and answers based on up-to-date information. Use markdown for formatting." }]
};

module.exports = async (req, res) => {
    // Set headers for CORS and JSON response
    res.setHeader('Content-Type', 'application/json');

    // Basic security checks
    if (req.method !== 'POST') {
        return res.status(405).json({ error: 'Method Not Allowed' });
    }

    if (!GEMINI_API_KEY) {
        return res.status(500).json({ error: 'Server configuration error: GEMINI_API_KEY is missing.' });
    }

    // Parse the request body from the frontend
    const { prompt, image } = req.body;
    if (!prompt && !image) {
        return res.status(400).json({ error: 'Missing prompt or image data in request.' });
    }

    // Construct the parts array for the Gemini API call
    const parts = [{ text: prompt }];
    if (image) {
        parts.push({ 
            inlineData: { 
                mimeType: "image/jpeg", // Assuming all uploads are treated as JPEG/image
                data: image 
            } 
        });
    }

    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${MODEL}:generateContent?key=${GEMINI_API_KEY}`;
    
    let geminiResponse;
    
    for (let attempt = 0; attempt < MAX_RETRIES; attempt++) {
        try {
            const apiCall = await fetch(apiUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    contents: [{ role: "user", parts: parts }],
                    systemInstruction: systemInstruction
                })
            });

            const data = await apiCall.json();
            
            if (apiCall.ok) {
                geminiResponse = data.candidates?.[0]?.content?.parts?.[0]?.text;
                if (geminiResponse) {
                    return res.status(200).json({ response: geminiResponse });
                } else {
                    return res.status(500).json({ error: 'Model response was empty or blocked by safety filters.' });
                }
            }
            
            // Handle permanent errors (bad key, invalid request)
            if (apiCall.status === 400 || apiCall.status === 403) {
                 return res.status(apiCall.status).json({ error: data.error?.message || "Invalid API request or unauthorized key." });
            }

            // Retry for transient errors (500, 429)
            if (attempt < MAX_RETRIES - 1) {
                const delay = Math.pow(2, attempt) * 1000 + Math.random() * 1000;
                await new Promise(resolve => setTimeout(resolve, delay));
            } else {
                return res.status(500).json({ error: `Gemini API failed after ${MAX_RETRIES} attempts. Error: ${data.error?.message || 'Unknown upstream error.'}` });
            }

        } catch (error) {
            // Network errors on the server side
            if (attempt < MAX_RETRIES - 1) {
                const delay = Math.pow(2, attempt) * 1000 + Math.random() * 1000;
                await new Promise(resolve => setTimeout(resolve, delay));
            } else {
                return res.status(500).json({ error: `Proxy failed to connect after ${MAX_RETRIES} attempts. Network Error: ${error.message}` });
            }
        }
    }
};
